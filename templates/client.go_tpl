package {{ .PkgName }}

import (
	"time"

	"golang.org/x/net/context"

	"github.com/achilleasa/usrv"
	"github.com/achilleasa/usrv/transport"

	{{if eq .SrvMessageType "protobuf"}}"github.com/golang/protobuf/proto"
	{{else if eq .SrvMessageType "json"}}"encoding/json"{{end}}
)

{{range .SrvEndpoints}}
// This struct defines the response of the Client {{.}} method.
type Srv{{.}}Res struct {
	Response *{{.}}Res
	Error    error
}
{{end}}

// The client interface is implemented by all clients (real and mock)
type Client interface {
	{{range .SrvEndpoints}}
	// Send a request to the {{.}} endpoint with an optional timeout. Returns a
	// read-only channel that will emit a Srv{{.}}Res once a response is received by
	// the server.
	//
	// If the timeout expires or ctx is cancelled while the request is in progress, the client
	// will fail the request with ErrTimeout
	{{.}}(ctx context.Context, request *{{.}}Req, timeout time.Duration) <-chan Srv{{.}}Res
	{{end}}

	// Shutdown the client and abort any pending requests with ErrCancelled.
	// Invoking any client method after invoking Close() will result in an ErrClientClosed.
	Close()
}

// A client that performs requests to the service
type realClient struct {
	impl *usrv.Client
}

// Create a new client for this service using the same transport used by the server.
func NewClient() Client {
	return &realClient{
		impl: usrv.NewClient(transport.Amqp),
	}
}

// Create a new client for this service using the specified transport.
func NewClientWithTransport(transportSrv usrv.Transport) Client {
	return &realClient{
		impl: usrv.NewClient(transportSrv),
	}
}

{{range .SrvEndpoints}}
// Send a request to the {{.}} endpoint with an optional timeout. Returns a
// read-only channel that will emit a Srv{{.}}Res once a response is received by
// the server.
//
// If the timeout expires or ctx is cancelled while the request is in progress, the client
// will fail the request with ErrTimeout
func (client *realClient) {{.}}(ctx context.Context, request *{{.}}Req, timeout time.Duration) <-chan Srv{{.}}Res {

	// Allocate a buffered channel for the response. We use a buffered channel to
	// ensure that our job queue does not block if the requester never reads from the
	// returned channel
	clientResChan := make(chan Srv{{.}}Res, 1)
	go func() {
		{{if eq $.SrvMessageType "protobuf"}}// serialize protobuf
		payload, err := proto.Marshal(request)
		{{else if eq $.SrvMessageType "json"}}// serialize json
		payload, err := json.Marshal(request){{end}}
		if err != nil {
			clientResChan <- Srv{{.}}Res{
				Response: nil,
				Error:    err,
			}
			close(clientResChan)
			return
		}

		res := <-client.impl.RequestWithTimeout(
			ctx,
			&usrv.Message{Payload: payload},
			timeout,
			"{{$.SrvBaseEndpoint}}.{{.}}",
		)

		// Unserialize and emit response
		response := &{{.}}Res{}
		{{if eq $.SrvMessageType "protobuf"}}err = proto.Unmarshal(res.Message.Payload, response)
		{{else if eq $.SrvMessageType "json"}}err = json.Unmarshal(res.Message.Payload, response){{end}}
		if err != nil {
			response = nil
		}
		clientResChan <- Srv{{.}}Res{
			Response: response,
			Error:    err,
		}
		close(clientResChan)
	}()

	return clientResChan
}
{{end}}

// Shutdown the client and abort any pending requests with ErrCancelled.
// Invoking any client method after invoking Close() will result in an ErrClientClosed.
func (client *realClient) Close() {
	client.impl.Close()
}
